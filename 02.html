<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SimplePress: Anatomia di un Generatore di Siti Statici - Danilo Paissan</title>
  <meta name="description" content="Trentino dentro, ligure fuori">
  <style>
      :root {
        --color-pearl: #F8F9FA;
        --color-light-silver: #E9ECEF;
        --color-smoke-gray: #CED4DA;
        --color-medium-gray: #6C757D;
        --color-dark-gray: #212529;
      }
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        color: var(--color-dark-gray);
        background-color: var(--color-pearl);
      }
      
      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 0 20px;
      }
      
      header {
        background-color: var(--color-light-silver);
        border-bottom: 1px solid var(--color-smoke-gray);
        padding: 1rem 0;
      }
      
      nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .logo {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--color-dark-gray);
        text-decoration: none;
      }
      
      .nav-links {
        display: flex;
        list-style: none;
        gap: 2rem;
      }
      
      .nav-links a {
        color: var(--color-medium-gray);
        text-decoration: none;
        transition: color 0.3s ease;
      }
      
      .nav-links a:hover {
        color: var(--color-dark-gray);
      }
      
      main {
        min-height: calc(100vh - 200px);
        padding: 2rem 0;
      }
      
      .post-list {
        display: grid;
        gap: 2rem;
      }
      
      .post-card {
        background: white;
        border: 1px solid var(--color-smoke-gray);
        border-radius: 8px;
        padding: 1.5rem;
        transition: box-shadow 0.3s ease;
      }
      
      .post-card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      }
      
      .post-title {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }
      
      .post-title a {
        color: var(--color-dark-gray);
        text-decoration: none;
      }
      
      .post-excerpt {
        color: var(--color-medium-gray);
        margin-bottom: 1rem;
      }
      
      .read-more {
        color: var(--color-medium-gray);
        text-decoration: none;
        font-weight: 500;
      }
      
      .post-content {
        background: white;
        border: 1px solid var(--color-smoke-gray);
        border-radius: 8px;
        padding: 2rem;
        margin-bottom: 2rem;
      }
      
      .post-content h1, .post-content h2, .post-content h3 {
        margin-bottom: 1rem;
        color: var(--color-dark-gray);
      }
      
      .post-content p {
        margin-bottom: 1rem;
      }
      
      .post-content p a {
        color: rgb(33, 37, 41);
        text-decoration: none;
      }
      
      .back-link {
        display: inline-block;
        color: var(--color-medium-gray);
        text-decoration: none;
        margin-bottom: 2rem;
      }
      
      footer {
        background-color: var(--color-light-silver);
        border-top: 1px solid var(--color-smoke-gray);
        padding: 2rem 0;
        text-align: center;
        color: var(--color-medium-gray);
      }
      
      .language-switcher {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }
      
      .language-switcher a {
        color: var(--color-medium-gray);
        text-decoration: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        transition: background-color 0.3s ease;
      }
      
      .language-switcher a:hover {
        background-color: var(--color-smoke-gray);
      }
      
      .language-switcher a.active {
        background-color: var(--color-smoke-gray);
        color: var(--color-dark-gray);
      }
      
      @media (max-width: 768px) {
        .nav-links {
          gap: 1rem;
        }
        
        .container {
          padding: 0 15px;
        }
        
        .post-content {
          padding: 1.5rem;
        }
      }
    </style>
</head>
<body>
  <header>
    <nav class="container">
      <a href="index.html" class="logo">
        Danilo Paissan
      </a>
      <div style="display: flex; align-items: center; gap: 2rem;">
        <ul class="nav-links">
          <li><a href="index.html">Home</a></li>
          <li><a href="chi-sono.html">Chi sono</a></li>
        </ul>
        <div class="language-switcher">
          <a href="javascript:switchLanguage('en')" class="">EN</a>
          <span>|</span>
          <a href="javascript:switchLanguage('it')" class="active">IT</a>
        </div>
      </div>
    </nav>
  </header>
  
  <main class="container">
    
      <a href="index.html" class="back-link">&larr; Torna alla home</a>
      <article class="post-content">
        <h1>SimplePress: Anatomia di un Generatore di Siti Statici</h1>
        <hr>
<h2>Un Viaggio di Trent&#39;Anni nel Web</h2>
<p>Prima di addentrarci nei dettagli tecnici, lasciatemi raccontare una storia personale. Una storia che probabilmente condivido con molti di voi.</p>
<p>Trent&#39;anni fa, quando ho iniziato a muovere i primi passi sul web, i siti erano statici per definizione. File HTML scritti a mano, magari con qualche immagine GIF animata e uno sfondo piastrellato discutibile. Era un&#39;epoca pionieristica: si imparava l&#39;HTML da tutorial sparsi in rete, si caricavano i file via FTP, e ogni pagina era un piccolo manufatto artigianale. C&#39;era qualcosa di genuino in quella semplicità.</p>
<p>Poi è arrivato WordPress, e con lui la promessa di rendere tutto più facile. E per un po&#39; è stato vero. Ho abbracciato con entusiasmo il mondo dei CMS dinamici: database, PHP, temi, plugin. Potevi fare qualsiasi cosa! Volevi un form di contatto? C&#39;era un plugin. Un carosello? Un plugin. SEO? Plugin. Ogni problema aveva la sua soluzione preconfezionata.</p>
<p>Ma la complessità cresce in modo subdolo. Un plugin tira l&#39;altro, i temi diventano framework, gli aggiornamenti si accumulano, e prima che te ne accorga ti ritrovi a gestire un ecosistema fragile dove ogni update rischia di rompere qualcosa. Ho passato più tempo a debuggare conflitti tra plugin che a scrivere contenuti. La manutenzione era diventata un lavoro... un lavoro che facevo già otto ore al giorno. </p>
<p>C&#39;è stato un periodo di rigetto, lo ammetto. Ho smesso di scrivere sul web anche perché gestire tutta la baracca era diventata una palla. Il sito rimaneva lì, con i suoi plugin obsoleti e le sue vulnerabilità potenziali, come un giardino abbandonato che ti fa sentire in colpa ogni volta che ci passi davanti.</p>
<p>Poi ho deciso di ricominciare, ma con un approccio diverso. <strong>Minimalista</strong>. Solo quello che mi serve. Ho voluto tornare a quella semplicità originaria, ma con gli strumenti moderni. Niente database, niente CMS pesanti, niente dipendenze che si rompono. Solo file di testo che diventano pagine web. Ed è così che è nato SimplePress.</p>
<h3>I Vantaggi dei Siti Statici</h3>
<p>Un sito statico è composto solo da file HTML, CSS e JavaScript. Non c&#39;è database, non c&#39;è server applicativo, non ci sono query da ottimizzare. I vantaggi sono significativi:</p>
<p><strong>Velocità</strong>: senza elaborazione server-side, le pagine vengono servite istantaneamente. Il tempo di risposta è limitato solo dalla latenza di rete.</p>
<p><strong>Sicurezza</strong>: nessun database significa nessuna SQL injection. Nessun CMS significa nessuna vulnerabilità da patchare. La superficie di attacco è ridotta al minimo.</p>
<p><strong>Costi</strong>: un sito statico può essere ospitato gratuitamente su GitHub Pages, Netlify, o un semplice bucket S3. Niente costi di server, niente scaling da gestire.</p>
<p><strong>Affidabilità</strong>: meno componenti significa meno cose che possono rompersi. Un sito statico su una CDN ha uptime praticamente garantito.</p>
<h3>Essere Padroni dei Propri Contenuti</h3>
<p>C&#39;è un altro aspetto che mi sta particolarmente a cuore, e che va oltre le considerazioni tecniche: <strong>la proprietà dei propri contenuti</strong>.</p>
<p>Viviamo in un&#39;epoca in cui affidiamo le nostre parole, i nostri pensieri, le nostre creazioni a piattaforme terze. Social network, servizi di blogging, newsletter platform. È comodo, certo. Qualcun altro si occupa dell&#39;infrastruttura, tu devi solo scrivere.</p>
<p>Ma a che prezzo? I tuoi contenuti esistono finché la piattaforma decide che possono esistere. Un cambio di policy, un algoritmo che decide che sei meno visibile, un servizio che chiude i battenti (vi ricordate Google+? Vine? Tumblr nella sua forma originale?), e anni di impegno possono svanire o diventare inaccessibili.</p>
<p>E poi c&#39;è la questione della monetizzazione dei tuoi contenuti da parte di altri. Quando scrivi su una piattaforma gratuita, il prodotto sei tu. I tuoi testi, le tue interazioni, i tuoi dati alimentano algoritmi pubblicitari e modelli di business che non ti appartengono.</p>
<p>Un sito statico, ospitato su un servizio che controlli tu (anche solo un repository GitHub), ti restituisce questa proprietà. I file sono tuoi, in un formato aperto e portabile. Puoi spostarli dove vuoi, quando vuoi. Puoi fare backup, puoi archiviarli, puoi garantire che esisteranno finché lo deciderai tu.</p>
<p>È per questo che credo che un approccio semplice alla pubblicazione web non sia solo una scelta tecnica, ma anche una scelta di principio. Un modo per riprendersi un pezzetto di sovranità digitale in un mondo dove tendiamo a delegare sempre di più.</p>
<p>Per un blog personale, un portfolio, o un sito di documentazione, queste caratteristiche superano spesso la flessibilità di un CMS tradizionale. Ed è esattamente in questo contesto che nasce SimplePress.</p>
<hr>
<h2>L&#39;Architettura di SimplePress</h2>
<p>SimplePress segue un&#39;architettura modulare e pulita, organizzata in componenti con responsabilità ben definite. Vediamo come si struttura il progetto:</p>
<pre><code>simplepress/
├── md-src/              # Sorgenti Markdown
│   ├── 01.md           # Post numerati (ordine cronologico)
│   ├── 02.md           # Altri post...
│   ├── 01-en.md        # Traduzioni inglesi
│   └── chi-sono.md     # Pagina &quot;Chi sono&quot;
├── src/                # Codice TypeScript
│   ├── index.ts        # Entry point CLI
│   ├── site-generator.ts
│   ├── markdown-parser.ts
│   ├── template-engine.ts
│   ├── types.ts
│   └── config.ts
├── build/              # Output HTML generato
└── dist/               # TypeScript compilato
</code></pre>
<p>La separazione è netta: i contenuti risiedono in <code>md-src/</code> come file Markdown, il codice sorgente vive in <code>src/</code>, e l&#39;output finale viene generato in <code>build/</code>. Questo approccio mantiene ogni componente isolato e facilmente sostituibile.</p>
<h3>I Moduli TypeScript</h3>
<p>Il cuore di SimplePress è composto da sei moduli TypeScript, ognuno con una responsabilità specifica:</p>
<p><strong><code>types.ts</code></strong> - Le Fondamenta del Sistema dei Tipi</p>
<pre><code class="language-typescript">export interface Post {
  id: string;
  title: string;
  titleEn?: string;
  content: string;
  contentEn?: string;
  excerpt: string;
  excerptEn?: string;
  filename: string;
  order: number;
  createdAt: Date;
}

export interface Page {
  id: string;
  title: string;
  titleEn?: string;
  content: string;
  contentEn?: string;
  filename: string;
}

export type Language = &#39;it&#39; | &#39;en&#39;;
</code></pre>
<p>Queste interfacce definiscono il contratto che attraversa l&#39;intera applicazione. Un <code>Post</code> ha un titolo, un contenuto, un excerpt (riassunto), e opzionalmente le versioni inglesi di ciascuno. Il campo <code>order</code> determina l&#39;ordinamento cronologico: i numeri più bassi rappresentano i post più vecchi.</p>
<p><strong><code>config.ts</code></strong> - La Configurazione Centralizzata</p>
<pre><code class="language-typescript">export const siteConfig: SiteConfig = {
  title: &#39;Danilo Paissan&#39;,
  titleEn: &#39;Danilo Paissan&#39;,
  description: &#39;Trentino dentro, ligure fuori&#39;,
  descriptionEn: &#39;Trentino inside, ligurian outside&#39;,
  author: &#39;Danilo Paissan&#39;,
  colorPalette: {
    pearl: &#39;#F8F9FA&#39;,
    lightSilver: &#39;#E9ECEF&#39;,
    smokeGray: &#39;#CED4DA&#39;,
    mediumGray: &#39;#6C757D&#39;,
    darkGray: &#39;#212529&#39;
  }
};
</code></pre>
<p>La configurazione include anche tutte le traduzioni dell&#39;interfaccia utente: etichette di navigazione, testi del cookie banner, messaggi di sistema. Centralizzare queste informazioni rende semplice personalizzare il sito o aggiungere nuove lingue.</p>
<hr>
<h2>Il Flusso di Generazione</h2>
<p>Il processo di generazione segue un flusso lineare e prevedibile. Quando eseguiamo <code>npm run build</code>, accade quanto segue:</p>
<h3>Fase 1: Discovery dei Contenuti</h3>
<p>Il <code>SiteGenerator</code> inizia esplorando la directory <code>md-src/</code>:</p>
<pre><code class="language-typescript">private getPostFiles(): string[] {
  return fs.readdirSync(this.srcDir)
    .filter(file =&gt; {
      const isMarkdown = file.endsWith(&#39;.md&#39;);
      const isNumbered = /^\d+/.test(file);
      const isNotAboutPage = !file.startsWith(&#39;chi-sono&#39;);
      const isNotEnglishTranslation = !file.endsWith(&#39;-en.md&#39;);
      return isMarkdown &amp;&amp; isNumbered &amp;&amp; isNotAboutPage &amp;&amp; isNotEnglishTranslation;
    })
    .map(file =&gt; path.join(this.srcDir, file));
}
</code></pre>
<p>I file vengono filtrati con criteri precisi: solo file Markdown, con nome che inizia con un numero (per i post), escludendo la pagina &quot;Chi sono&quot; e le traduzioni inglesi (che verranno associate ai rispettivi post italiani).</p>
<p>La convenzione di naming è elegante nella sua semplicità: <code>01.md</code> è il primo post, <code>01-en.md</code> è la sua traduzione inglese. Il sistema riconosce automaticamente questa relazione e costruisce post bilingui.</p>
<h3>Fase 2: Parsing del Markdown</h3>
<p>Il <code>MarkdownParser</code> si occupa di trasformare i file Markdown in strutture dati utilizzabili. Utilizza la libreria <strong>marked</strong> per la conversione HTML, ma aggiunge funzionalità importanti.</p>
<p><strong>Estrazione dei Metadati (Frontmatter)</strong></p>
<p>SimplePress supporta il frontmatter YAML per specificare metadati opzionali:</p>
<pre><code class="language-markdown">---
title: Titolo Personalizzato
titleEn: Custom English Title
---

# Il Titolo nel Contenuto
Qui inizia il vero contenuto...
</code></pre>
<p>Il parser estrae questi metadati e li separa dal contenuto principale:</p>
<pre><code class="language-typescript">private extractMetadata(content: string): { metadata: Record&lt;string, string&gt;, cleanContent: string } {
  const lines = content.split(&#39;\n&#39;);
  const metadata: Record&lt;string, string&gt; = {};
  
  if (lines[0]?.trim() === &#39;---&#39;) {
    const endIndex = lines.findIndex((line, index) =&gt; index &gt; 0 &amp;&amp; line.trim() === &#39;---&#39;);
    if (endIndex &gt; 0) {
      for (let i = 1; i &lt; endIndex; i++) {
        const line = lines[i];
        const colonIndex = line.indexOf(&#39;:&#39;);
        if (colonIndex &gt; 0) {
          const key = line.substring(0, colonIndex).trim();
          const value = line.substring(colonIndex + 1).trim();
          metadata[key] = value;
        }
      }
      cleanContent = lines.slice(endIndex + 1).join(&#39;\n&#39;);
    }
  }
  
  return { metadata, cleanContent };
}
</code></pre>
<p><strong>Generazione Automatica dell&#39;Excerpt</strong></p>
<p>Per la homepage, ogni post mostra un breve riassunto. Il parser lo genera automaticamente estraendo i primi 200 caratteri del contenuto, rimuovendo i tag HTML:</p>
<pre><code class="language-typescript">private generateExcerpt(htmlContent: string, maxLength: number = 200): string {
  const textContent = htmlContent.replace(/&lt;[^&gt;]*&gt;/g, &#39;&#39;);
  const firstParagraph = textContent.split(&#39;\n\n&#39;)[0];
  return firstParagraph.length &gt; maxLength 
    ? firstParagraph.substring(0, maxLength).trim() + &#39;...&#39;
    : firstParagraph;
}
</code></pre>
<p><strong>Gestione dei Titoli</strong></p>
<p>Un dettaglio sottile ma importante: il parser rimuove il primo tag H1 dal contenuto HTML. Perché? Il titolo viene già visualizzato dal template della pagina, quindi includerlo anche nel contenuto causerebbe una duplicazione. Questo tipo di attenzione ai dettagli distingue un tool ben progettato.</p>
<h3>Fase 3: Generazione dei Template</h3>
<p>Il <code>TemplateEngine</code> è il componente più corposo, responsabile di trasformare i dati in pagine HTML complete. Genera tre tipi di pagine:</p>
<p><strong>Homepage</strong> (<code>index.html</code> e <code>index-en.html</code>)</p>
<p>Mostra l&#39;elenco di tutti i post con titolo ed excerpt. Per la versione inglese, vengono mostrati solo i post che hanno una traduzione disponibile.</p>
<p><strong>Pagine Post</strong> (<code>01.html</code>, <code>01-en.html</code>, etc.)</p>
<p>Ogni post ha la sua pagina dedicata, con navigazione per tornare alla home e switch di lingua.</p>
<p><strong>Pagine Statiche</strong> (<code>chi-sono.html</code> e <code>about.html</code>)</p>
<p>La pagina &quot;Chi sono&quot; segue lo stesso pattern bilingue.</p>
<h3>Il Sistema di Stili Inline</h3>
<p>Una scelta architetturale interessante: SimplePress include tutti gli stili CSS direttamente nell&#39;HTML, evitando file esterni:</p>
<pre><code class="language-typescript">private getCSSStyles(): string {
  const { colorPalette } = siteConfig;
  return `
    :root {
      --color-pearl: ${colorPalette.pearl};
      --color-light-silver: ${colorPalette.lightSilver};
      --color-smoke-gray: ${colorPalette.smokeGray};
      --color-medium-gray: ${colorPalette.mediumGray};
      --color-dark-gray: ${colorPalette.darkGray};
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, &#39;Segoe UI&#39;, Roboto, sans-serif;
      line-height: 1.6;
      color: var(--color-dark-gray);
      background-color: var(--color-pearl);
    }
    /* ... altri stili ... */
  `;
}
</code></pre>
<p>Questa scelta ha pro e contro. Da un lato, ogni pagina è completamente autonoma (non dipende da file esterni). Dall&#39;altro, gli stili vengono ripetuti in ogni file HTML. Per un blog con poche pagine, il trade-off è favorevole: la semplicità vince sulla dimensione dei file.</p>
<hr>
<h2>Il Supporto Bilingue</h2>
<p>Una delle caratteristiche distintive di SimplePress è il supporto nativo per contenuti bilingui (italiano/inglese). L&#39;implementazione è elegante e non invasiva.</p>
<h3>Contenuti Bilingui</h3>
<p>Ci sono due modi per fornire contenuti in inglese:</p>
<p><strong>1. File Separati</strong>: per ogni <code>01.md</code>, si può creare un <code>01-en.md</code> con la traduzione completa. Il sistema li associa automaticamente.</p>
<p><strong>2. Frontmatter</strong>: per contenuti più brevi, si possono includere le traduzioni direttamente nel frontmatter:</p>
<pre><code class="language-markdown">---
titleEn: English Title
contentEn: English content here...
excerptEn: English excerpt...
---

# Titolo Italiano
Contenuto italiano qui...
</code></pre>
<h3>Lo Switch di Lingua</h3>
<p>Ogni pagina include un selettore di lingua nell&#39;header. Il codice JavaScript che gestisce lo switch è sorprendentemente semplice:</p>
<pre><code class="language-javascript">function switchLanguage(lang) {
  const currentPath = window.location.pathname;
  const filename = currentPath.split(&#39;/&#39;).pop() || &#39;index.html&#39;;
  
  let newFilename;
  if (lang === &#39;en&#39;) {
    if (filename === &#39;index.html&#39;) {
      newFilename = &#39;index-en.html&#39;;
    } else if (filename === &#39;chi-sono.html&#39;) {
      newFilename = &#39;about.html&#39;;
    } else if (!filename.includes(&#39;-en.html&#39;)) {
      newFilename = filename.replace(&#39;.html&#39;, &#39;-en.html&#39;);
    }
  } else {
    // Logica inversa per italiano
  }
  
  window.location.href = newFilename;
}
</code></pre>
<p>La logica mappa ogni pagina italiana alla sua controparte inglese seguendo convenzioni consistenti: <code>index.html</code> ↔ <code>index-en.html</code>, <code>chi-sono.html</code> ↔ <code>about.html</code>, <code>01.html</code> ↔ <code>01-en.html</code>.</p>
<h3>Gestione dei Post Non Tradotti</h3>
<p>Cosa succede se un utente cerca di accedere alla versione inglese di un post non tradotto? SimplePress genera una pagina &quot;non disponibile&quot; con un messaggio appropriato, invece di mostrare un errore o il contenuto italiano. È un tocco di attenzione all&#39;esperienza utente.</p>
<hr>
<h2>Conformità GDPR: Il Cookie Banner</h2>
<p>In un&#39;epoca di crescente attenzione alla privacy, SimplePress include un sistema di gestione dei cookie conforme al GDPR e alla direttiva ePrivacy.</p>
<h3>Il Paradosso del Sito Senza Cookie</h3>
<p>Ecco un aspetto interessante: SimplePress non utilizza cookie di tracciamento o profilazione. Tecnicamente, potrebbe non servire alcun banner. Tuttavia, la normativa richiede di informare gli utenti anche solo sull&#39;uso di cookie tecnici (come quelli usati per memorizzare il consenso stesso).</p>
<h3>L&#39;Implementazione</h3>
<p>Il cookie banner appare al primo accesso e offre due opzioni: Accetta o Rifiuta.</p>
<pre><code class="language-javascript">function checkCookieConsent() {
  const consent = localStorage.getItem(&#39;cookieConsent&#39;);
  if (consent === &#39;rejected&#39;) {
    document.body.innerHTML = `
      &lt;div class=&quot;cookie-rejected&quot;&gt;
        &lt;h2&gt;È necessario accettare i cookie per accedere al sito.&lt;/h2&gt;
        &lt;button onclick=&quot;resetCookieConsent()&quot;&gt;Accetto&lt;/button&gt;
      &lt;/div&gt;
    `;
    return;
  }
  if (!consent) {
    document.getElementById(&#39;cookie-banner&#39;).style.display = &#39;block&#39;;
  }
}
</code></pre>
<p>Se l&#39;utente rifiuta i cookie, l&#39;accesso al sito viene bloccato. Può sembrare drastico, ma è una scelta lecita: il sito dichiara trasparentemente di non usare cookie di tracciamento, e l&#39;utente può scegliere di non procedere.</p>
<p>Il consenso viene memorizzato in <code>localStorage</code>, che tecnicamente non è un cookie ma uno storage locale del browser. Questa scelta evita il paradosso del &quot;cookie per ricordare che non vuoi cookie&quot;.</p>
<hr>
<h2>Il Sistema di Build</h2>
<p>SimplePress offre diversi comandi per gestire il ciclo di sviluppo:</p>
<pre><code class="language-bash">npm run setup     # Installa dipendenze e compila
npm run build     # Compila TypeScript e genera il sito
npm run generate  # Solo generazione (TypeScript già compilato)
npm run watch     # Rigenera automaticamente ai cambiamenti
npm run serve     # Server locale per preview
npm run clean     # Rimuove i file generati
</code></pre>
<h3>Watch Mode</h3>
<p>La modalità watch è particolarmente utile durante la scrittura:</p>
<pre><code class="language-typescript">watch(): void {
  console.log(`Watching ${this.srcDir} for changes...`);
  
  fs.watch(this.srcDir, { recursive: true }, (eventType, filename) =&gt; {
    if (filename &amp;&amp; (filename.endsWith(&#39;.md&#39;) || filename.includes(&#39;img/&#39;))) {
      console.log(`File changed: ${filename}`);
      console.log(&#39;Regenerating site...&#39;);
      this.generate();
    }
  });
}
</code></pre>
<p>Ogni modifica a un file Markdown o a un&#39;immagine triggera una rigenerazione completa del sito. Per un blog con poche decine di post, questa operazione è istantanea.</p>
<h3>Gestione delle Immagini</h3>
<p>SimplePress copia automaticamente le immagini da <code>md-src/img/</code> a <code>build/img/</code>:</p>
<pre><code class="language-typescript">private copyImages(): void {
  const srcImgDir = path.join(this.srcDir, &#39;img&#39;);
  const buildImgDir = path.join(this.buildDir, &#39;img&#39;);

  if (!fs.existsSync(srcImgDir)) {
    return;
  }

  if (!fs.existsSync(buildImgDir)) {
    fs.mkdirSync(buildImgDir, { recursive: true });
  }

  const files = fs.readdirSync(srcImgDir);
  for (const file of files) {
    const srcFile = path.join(srcImgDir, file);
    const buildFile = path.join(buildImgDir, file);
    
    if (fs.statSync(srcFile).isFile()) {
      fs.copyFileSync(srcFile, buildFile);
    }
  }
}
</code></pre>
<p>Nel Markdown, le immagini possono essere referenziate con path relativi: <code>![Descrizione](img/mia-immagine.png)</code>.</p>
<hr>
<h2>Il Design System</h2>
<p>SimplePress utilizza una palette di colori attentamente selezionata, basata su tonalità di grigio che garantiscono leggibilità e un aspetto professionale:</p>
<table>
<thead>
<tr>
<th>Nome</th>
<th>Colore</th>
<th>Uso</th>
</tr>
</thead>
<tbody><tr>
<td>Pearl</td>
<td>#F8F9FA</td>
<td>Sfondo principale</td>
</tr>
<tr>
<td>Light Silver</td>
<td>#E9ECEF</td>
<td>Header e footer</td>
</tr>
<tr>
<td>Smoke Gray</td>
<td>#CED4DA</td>
<td>Bordi</td>
</tr>
<tr>
<td>Medium Gray</td>
<td>#6C757D</td>
<td>Testo secondario</td>
</tr>
<tr>
<td>Dark Gray</td>
<td>#212529</td>
<td>Testo principale</td>
</tr>
</tbody></table>
<p>Questa palette neutra funziona bene per contenuti testuali, dove il focus deve rimanere sul contenuto stesso piuttosto che sull&#39;interfaccia.</p>
<h3>Design Responsive</h3>
<p>Gli stili includono media query per adattarsi a schermi più piccoli:</p>
<pre><code class="language-css">@media (max-width: 768px) {
  .nav-links {
    gap: 1rem;
  }
  
  .container {
    padding: 0 15px;
  }
  
  .post-content {
    padding: 1.5rem;
  }
}
</code></pre>
<p>Il layout è mobile-first: funziona bene su smartphone e si espande elegantemente su schermi più grandi.</p>
<hr>
<h2>Estendibilità e Personalizzazione</h2>
<p>SimplePress è progettato per essere facilmente personalizzabile:</p>
<p><strong>Configurazione</strong>: modificando <code>src/config.ts</code> si possono cambiare titolo, descrizione, autore, palette colori e tutte le traduzioni.</p>
<p><strong>Stili</strong>: il CSS in <code>template-engine.ts</code> può essere modificato per cambiare completamente l&#39;aspetto del sito.</p>
<p><strong>Struttura</strong>: aggiungendo nuovi tipi di pagine in <code>types.ts</code> e relativi metodi di generazione, si può estendere il sistema.</p>
<p><strong>Traduzioni</strong>: aggiungendo nuove chiavi in <code>translations</code>, il supporto per altre lingue è immediato (anche se richiederebbe modifiche al type <code>Language</code>).</p>
<hr>
<h2>Conclusioni</h2>
<p>SimplePress rappresenta un approccio minimalista ma completo alla generazione di siti statici. Non compete con Hugo o Jekyll per funzionalità, ma offre qualcosa di diverso: un codebase leggibile e modificabile, che può essere compreso interamente in un pomeriggio.</p>
<p>Per chi gestisce un blog personale o un piccolo sito, questo livello di controllo è prezioso. Non ci sono dipendenze misteriose, non ci sono comportamenti magici da debuggare, non ci sono aggiornamenti che rischiano di rompere tutto.</p>
<p>La scelta di TypeScript garantisce type safety e autocompletamento durante lo sviluppo. L&#39;architettura modulare permette di modificare un componente senza impattare gli altri. Il supporto bilingue nativo evita la complessità di plugin esterni. E la conformità GDPR out-of-the-box elimina una preoccupazione comune per i siti europei.</p>
<hr>
<p><em>Vuoi provare SimplePress? Il setup è semplice:</em></p>
<pre><code class="language-bash">git clone [repository]
cd simplepress
npm run setup
# Aggiungi i tuoi contenuti in md-src/
npm run build
npm run serve
# Visita http://localhost:8000
</code></pre>
<p><em>Il tuo blog statico, bilingue e GDPR-compliant è pronto in pochi minuti.</em></p>
      </article>
    
  </main>
  
  <footer>
    <div class="container">
      <p>&copy; 2024 Danilo Paissan. Tutti i diritti riservati.</p>
    </div>
  </footer>
  
  
      <div id="cookie-banner" class="cookie-banner" style="display: none;">
        <div class="cookie-content">
          <h3>Informativa sui Cookie</h3>
          <p>Questo sito non utilizza cookie di tracciamento o di profilazione. I cookie tecnici vengono utilizzati solo per il funzionamento del sito.</p>
          <div class="cookie-buttons">
            <button onclick="acceptCookies()" class="btn-accept">Accetto</button>
            <button onclick="rejectCookies()" class="btn-reject">Rifiuto</button>
          </div>
        </div>
      </div>
      
      <style>
        .cookie-banner {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          background: var(--color-dark-gray);
          color: white;
          z-index: 1000;
          padding: 1rem;
        }
        
        .cookie-content {
          max-width: 800px;
          margin: 0 auto;
        }
        
        .cookie-content h3 {
          margin-bottom: 0.5rem;
        }
        
        .cookie-content p {
          margin-bottom: 1rem;
        }
        
        .cookie-buttons {
          display: flex;
          gap: 1rem;
        }
        
        .cookie-buttons button {
          padding: 0.5rem 1rem;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
        }
        
        .btn-accept {
          background: var(--color-light-silver);
          color: var(--color-dark-gray);
        }
        
        .btn-reject {
          background: var(--color-medium-gray);
          color: white;
        }
        
        .cookie-rejected {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100vh;
          text-align: center;
        }
      </style>
      
      <script>
        function checkCookieConsent() {
          const consent = localStorage.getItem('cookieConsent');
          if (consent === 'rejected') {
            document.body.innerHTML = `
              <div class="cookie-rejected">
                <h2>È necessario accettare i cookie per accedere al sito.</h2>
                <button onclick="resetCookieConsent()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: var(--color-medium-gray); color: white; border: none; border-radius: 4px; cursor: pointer;">
                  Accetto
                </button>
              </div>
            `;
            return;
          }
          if (!consent) {
            document.getElementById('cookie-banner').style.display = 'block';
          }
        }
        
        function acceptCookies() {
          localStorage.setItem('cookieConsent', 'accepted');
          document.getElementById('cookie-banner').style.display = 'none';
        }
        
        function rejectCookies() {
          localStorage.setItem('cookieConsent', 'rejected');
          location.reload();
        }
        
        function resetCookieConsent() {
          localStorage.removeItem('cookieConsent');
          location.reload();
        }
        
        // Check consent on page load
        document.addEventListener('DOMContentLoaded', checkCookieConsent);
      </script>
    
  
  <script>
    function switchLanguage(lang) {
      const currentPath = window.location.pathname;
      const filename = currentPath.split('/').pop() || 'index.html';
      
      let newFilename;
      if (lang === 'en') {
        if (filename === 'index.html') {
          newFilename = 'index-en.html';
        } else if (filename === 'chi-sono.html') {
          newFilename = 'about.html';
        } else if (!filename.includes('-en.html')) {
          newFilename = filename.replace('.html', '-en.html');
        } else {
          newFilename = filename;
        }
      } else {
        if (filename === 'index-en.html') {
          newFilename = 'index.html';
        } else if (filename === 'about.html') {
          newFilename = 'chi-sono.html';
        } else if (filename.includes('-en.html')) {
          newFilename = filename.replace('-en.html', '.html');
        } else {
          newFilename = filename;
        }
      }
      
      window.location.href = newFilename;
    }
  </script>
</body>
</html>