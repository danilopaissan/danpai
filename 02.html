<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Come funziona la baracca - Danilo Paissan</title>
  <meta name="description" content="Trentino dentro, ligure fuori">
  <style>
      :root {
        --color-pearl: #F8F9FA;
        --color-light-silver: #E9ECEF;
        --color-smoke-gray: #CED4DA;
        --color-medium-gray: #6C757D;
        --color-dark-gray: #212529;
      }
      
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        line-height: 1.6;
        color: var(--color-dark-gray);
        background-color: var(--color-pearl);
      }
      
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 0 20px;
      }
      
      header {
        background-color: var(--color-light-silver);
        border-bottom: 1px solid var(--color-smoke-gray);
        padding: 1rem 0;
      }
      
      nav {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      
      .logo {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--color-dark-gray);
        text-decoration: none;
      }
      
      .nav-links {
        display: flex;
        list-style: none;
        gap: 2rem;
      }
      
      .nav-links a {
        color: var(--color-medium-gray);
        text-decoration: none;
        transition: color 0.3s ease;
      }
      
      .nav-links a:hover {
        color: var(--color-dark-gray);
      }
      
      main {
        min-height: calc(100vh - 200px);
        padding: 2rem 0;
      }
      
      .post-list {
        display: grid;
        gap: 2rem;
      }
      
      .post-card {
        background: white;
        border: 1px solid var(--color-smoke-gray);
        border-radius: 8px;
        padding: 1.5rem;
        transition: box-shadow 0.3s ease;
      }
      
      .post-card:hover {
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      }
      
      .post-title {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
      }
      
      .post-title a {
        color: var(--color-dark-gray);
        text-decoration: none;
      }
      
      .post-excerpt {
        color: var(--color-medium-gray);
        margin-bottom: 1rem;
      }
      
      .read-more {
        color: var(--color-medium-gray);
        text-decoration: none;
        font-weight: 500;
      }
      
      .post-content {
        background: white;
        border: 1px solid var(--color-smoke-gray);
        border-radius: 8px;
        padding: 2rem;
        margin-bottom: 2rem;
      }
      
      .post-content h1, .post-content h2, .post-content h3 {
        margin-bottom: 1rem;
        color: var(--color-dark-gray);
      }
      
      .post-content p {
        margin-bottom: 1rem;
      }
      
      .post-content p a {
        color: rgb(33, 37, 41);
        text-decoration: none;
      }
      
      .post-content code {
        background-color: var(--color-light-silver);
        border: 1px solid var(--color-smoke-gray);
        border-radius: 4px;
        padding: 0.2em 0.5em;
        font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Monaco, monospace;
        font-size: 0.9em;
        color: #c7254e;
      }

      .post-content pre code {
        display: block;
        background-color: var(--color-dark-gray);
        color: var(--color-pearl);
        border: none;
        border-radius: 8px;
        padding: 1rem 1.25rem;
        overflow-x: auto;
        font-size: 0.875em;
        line-height: 1.7;
      }

      .post-content pre {
        margin-bottom: 1rem;
      }
      
      .back-link {
        display: inline-block;
        color: var(--color-medium-gray);
        text-decoration: none;
        margin-bottom: 2rem;
      }
      
      footer {
        background-color: var(--color-light-silver);
        border-top: 1px solid var(--color-smoke-gray);
        padding: 2rem 0;
        text-align: center;
        color: var(--color-medium-gray);
      }
      
      .language-switcher {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }
      
      .language-switcher a {
        color: var(--color-medium-gray);
        text-decoration: none;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        transition: background-color 0.3s ease;
      }
      
      .language-switcher a:hover {
        background-color: var(--color-smoke-gray);
      }
      
      .language-switcher a.active {
        background-color: var(--color-smoke-gray);
        color: var(--color-dark-gray);
      }
      
      .social-links {
        margin-top: 2rem;
        padding-top: 1.5rem;
        border-top: 1px solid var(--color-smoke-gray);
      }
      
      .social-links h3 {
        margin-bottom: 1rem;
        color: var(--color-dark-gray);
      }
      
      .social-links-list {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        list-style: none;
      }
      
      .social-links-list a {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background-color: var(--color-light-silver);
        color: var(--color-dark-gray);
        text-decoration: none;
        border-radius: 4px;
        transition: background-color 0.3s ease;
      }
      
      .social-links-list a:hover {
        background-color: var(--color-smoke-gray);
      }
      
      @media (max-width: 768px) {
        .nav-links {
          gap: 1rem;
        }
        
        .container {
          padding: 0 15px;
        }
        
        .post-content {
          padding: 1.5rem;
        }
      }
    </style>
</head>
<body>
  <header>
    <nav class="container">
      <a href="index.html" class="logo">
        Danilo Paissan
      </a>
      <div style="display: flex; align-items: center; gap: 2rem;">
        <ul class="nav-links">
          <li><a href="index.html">Home</a></li>
          <li><a href="chi-sono.html">Chi sono</a></li>
        </ul>
        <div class="language-switcher">
          <a href="javascript:switchLanguage('en')" class="">EN</a>
          <span>|</span>
          <a href="javascript:switchLanguage('it')" class="active">IT</a>
        </div>
      </div>
    </nav>
  </header>
  
  <main class="container">
    
      <a href="index.html" class="back-link">&larr; Torna alla home</a>
      <article class="post-content">
        <h1>Come funziona la baracca</h1>
        <hr>
<p>C&#39;è qualcosa di profondamente soddisfacente nel premere &quot;push&quot; e sapere che, nel giro di pochi minuti, il tuo sito sarà aggiornato. Nessun FTP da aprire, nessun server da configurare, nessun file da copiare manualmente. Solo tu, il tuo codice, e un sistema che fa tutto il lavoro sporco al posto tuo.</p>
<p>È esattamente quello che ho fatto in modo che succeda con questo sito: scrivo un articolo in Markdown, faccio commit e push, e il sito si aggiorna da solo. Sembra magia, ma è solo GitHub Actions che fa il suo lavoro. E la cosa bella è che questa &quot;magia&quot; è accessibile a chiunque, gratuitamente.</p>
<p>In questo articolo vi racconto come ho configurato il sistema di pubblicazione automatica, con un twist interessante: il codice sorgente e il sito pubblicato vivono in due repository separati.</p>
<hr>
<h2>Perché Separare Sorgente e Pubblicazione</h2>
<p>Quando ho iniziato a pensare di utilizzare GitHub Pages per l&#39;hosting di questo sito, mi sono trovato di fronte a una scelta: tenere tutto nello stesso repository o separare il codice sorgente dal sito pubblicato.</p>
<p>La prima opzione è la più semplice: hai un solo repository, e GitHub Pages pubblica direttamente da lì. È l&#39;approccio che va bene per la maggior parte dei progetti. Ma nel mio caso c&#39;erano alcune considerazioni che mi hanno spinto verso la seconda strada.</p>
<p><strong>Separazione delle responsabilità</strong>: il repository sorgente contiene TypeScript, configurazioni di build, file di sviluppo, test. Niente di tutto questo serve al sito finale. Mescolando le due cose, il repository diventa confuso e il suo scopo meno chiaro.</p>
<p><strong>Privacy selettiva</strong>: magari vuoi che il codice sorgente rimanga privato, ma il sito deve essere pubblico. Con repository separati, questa distinzione è naturale.</p>
<p><strong>Storico git più pulito</strong>: il repository di pubblicazione contiene solo i file HTML, CSS e JavaScript generati. Ogni commit rappresenta una nuova versione del sito, senza il &quot;rumore&quot; dei commit di sviluppo.</p>
<p><strong>Flessibilità</strong>: puoi avere più repository sorgente che pubblicano sullo stesso sito, o un sorgente che pubblica su più destinazioni diverse.</p>
<hr>
<h2>Perchè GitHub Pages</h2>
<p>Prima di addentrarci nell&#39;automazione, vale la pena ricordare perché GitHub Pages è una scelta ideale per siti statici come blog e portfolio.</p>
<p><strong>È gratuito</strong>. Per repository pubblici, non paghi nulla. Zero. Niente canoni mensili, niente costi a consumo, niente sorprese in bolletta.</p>
<p><strong>HTTPS automatico</strong>. Il certificato SSL viene generato e rinnovato automaticamente. Il tuo sito sarà sempre accessibile via HTTPS senza che tu debba fare nulla.</p>
<p><strong>CDN globale</strong>. I tuoi file vengono distribuiti su server in tutto il mondo. Un visitatore dal Giappone e uno dall&#39;Italia riceveranno i contenuti da server vicini a loro, con tempi di caricamento ottimali.</p>
<p><strong>Affidabilità</strong>. L&#39;infrastruttura di GitHub è robusta. Il tuo sito sarà online praticamente sempre, senza che tu debba preoccuparti di uptime, backup o disaster recovery.</p>
<p><strong>Domini personalizzati</strong>. Puoi collegare il tuo dominio personale con pochi click. GitHub si occupa anche del certificato HTTPS per il dominio custom.</p>
<p>Certo, ci sono limiti: 1GB di spazio, 100GB di banda al mese, niente contenuti dinamici. Ma per un blog personale o un portfolio, questi limiti sono più che sufficienti. E se un giorno dovessi superarli, beh, complimenti: hai un problema che la maggior parte dei blogger vorrebbe avere.</p>
<hr>
<h2>GitHub Actions, cos&#39;è?</h2>
<p>GitHub Actions è il sistema di automazione integrato in GitHub. Puoi pensarlo come un maggiordomo digitale: gli dai una lista di istruzioni, e lui le esegue fedelmente ogni volta che si verifica un certo evento.</p>
<p>Nel nostro caso, l&#39;evento è un push sul branch principale. Le istruzioni sono: prendi il codice, genera il sito, pubblicalo.</p>
<p>Le Actions sono definite in file YAML nella cartella <code>.github/workflows/</code> del repository. Ogni file descrive un &quot;workflow&quot;, una sequenza di operazioni da eseguire.</p>
<p>La cosa bella è che questi workflow vengono eseguiti su macchine virtuali messe a disposizione da GitHub. Non devi configurare server, non devi installare software, non devi preoccuparti di nulla. Definisci cosa vuoi fare, e GitHub si occupa del come.</p>
<hr>
<h2>Anatomia di un Workflow di Deploy</h2>
<p>Vediamo come funziona un workflow che genera un sito statico e lo pubblica su un repository esterno. Non vi mostrerò il codice esatto (ogni progetto ha le sue specificità), ma vi spiego il flusso logico.</p>
<h3>Trigger: Quando Si Attiva</h3>
<p>Il workflow si attiva in due modi:</p>
<ol>
<li><strong>Automaticamente</strong> quando fai push sul branch principale</li>
<li><strong>Manualmente</strong> dalla tab Actions su GitHub (utile per forzare un deploy)</li>
</ol>
<p>La possibilità di trigger manuale è sottovalutata. A volte vuoi ricostruire il sito senza modificare nulla, magari perché hai aggiornato qualcosa nel repository di destinazione. Con un click, puoi farlo.</p>
<h3>Fase 1: Preparazione dell&#39;Ambiente</h3>
<p>La prima cosa che fa il workflow è preparare l&#39;ambiente di lavoro:</p>
<ol>
<li><strong>Checkout</strong>: scarica il codice sorgente dal repository</li>
<li><strong>Setup Node.js</strong>: installa la versione corretta di Node.js</li>
<li><strong>Installazione dipendenze</strong>: esegue <code>npm ci</code> per installare le dipendenze in modo riproducibile</li>
</ol>
<p>Questa fase è identica per qualsiasi progetto Node.js. La magia inizia dopo.</p>
<h3>Fase 2: Generazione del Sito</h3>
<p>Qui entra in gioco la logica specifica di SimplePress:</p>
<ol>
<li><strong>Pulizia</strong>: rimuove eventuali build precedenti</li>
<li><strong>Build</strong>: compila TypeScript e genera le pagine HTML</li>
</ol>
<p>Al termine di questa fase, la cartella <code>build/</code> contiene il sito statico completo, pronto per essere pubblicato.</p>
<h3>Fase 3: Pubblicazione sul Repository Esterno</h3>
<p>Questa è la parte interessante. Il workflow deve prendere i file generati e copiarli su un repository completamente diverso. Come fa?</p>
<p>GitHub Actions mette a disposizione &quot;actions&quot; predefinite, piccoli moduli riutilizzabili che fanno operazioni comuni. Una di queste, molto popolare, permette di pubblicare file su GitHub Pages, anche su repository esterni.</p>
<p>L&#39;action:</p>
<ul>
<li>Si connette al repository di destinazione usando credenziali sicure</li>
<li>Crea un nuovo commit con i file generati</li>
<li>Fa push di questo commit sul branch corretto</li>
</ul>
<p>Dal punto di vista del repository di destinazione, è come se qualcuno avesse fatto un commit con i nuovi file. Semplice, pulito, tracciabile.</p>
<hr>
<h2>La Questione della Sicurezza</h2>
<p>Per permettere a un workflow di scrivere su un altro repository, servono delle credenziali. Non puoi semplicemente fare push su un repository qualsiasi (per fortuna!).</p>
<p>Ci sono due approcci principali:</p>
<h3>Personal Access Token</h3>
<p>È un token che generi dal tuo account GitHub e che dà accesso ai tuoi repository. Lo memorizzi come &quot;secret&quot; nel repository sorgente, e il workflow lo usa per autenticarsi.</p>
<p><strong>Pro</strong>: semplice da configurare.
<strong>Contro</strong>: dà accesso a tutti i tuoi repository (o a tutti quelli pubblici), non solo a quello di destinazione.</p>
<h3>Deploy Keys</h3>
<p>Sono chiavi SSH specifiche per un singolo repository. Ne generi una, aggiungi la parte pubblica al repository di destinazione come &quot;deploy key&quot;, e memorizzi la parte privata come secret nel repository sorgente.</p>
<p><strong>Pro</strong>: accesso limitato al solo repository di destinazione, più sicuro.
<strong>Contro</strong>: richiede qualche passaggio in più per la configurazione.</p>
<p>Per un progetto personale, entrambi gli approcci funzionano. Se sei particolarmente attento alla sicurezza, le Deploy Keys sono la scelta migliore. Io preferisco questo approccio: il principio del minimo privilegio è sempre una buona pratica.</p>
<hr>
<h2>Il Flusso Completo in Azione</h2>
<p>Ricapitoliamo cosa succede quando faccio push di un nuovo articolo:</p>
<ol>
<li><strong>Push</strong>: il commit arriva sul repository sorgente</li>
<li><strong>Trigger</strong>: GitHub Actions rileva il push e avvia il workflow</li>
<li><strong>Checkout</strong>: il codice viene scaricato sulla macchina virtuale</li>
<li><strong>Setup</strong>: Node.js viene configurato, le dipendenze installate</li>
<li><strong>Build</strong>: SimplePress genera il sito statico</li>
<li><strong>Deploy</strong>: i file vengono copiati sul repository di pubblicazione</li>
<li><strong>GitHub Pages</strong>: rileva il nuovo commit e aggiorna il sito</li>
</ol>
<p>Tutto questo succede in pochi minuti, senza alcun intervento manuale. Posso scrivere un articolo dal telefono, fare commit da una web interface, e il sito si aggiorna comunque.</p>
<hr>
<h2>Vantaggi Inaspettati</h2>
<p>Oltre ai benefici ovvi (automazione, comodità), questo setup ha alcuni vantaggi meno scontati:</p>
<p><strong>Rollback facile</strong>: ogni deploy è un commit nel repository di pubblicazione. Se qualcosa va storto, basta fare revert all&#39;ultimo commit buono e il sito torna come prima.</p>
<p><strong>Audit trail</strong>: puoi vedere esattamente quando ogni versione del sito è stata pubblicata, e quale commit sorgente l&#39;ha generata.</p>
<p><strong>Collaborazione semplificata</strong>: se un giorno volessi accettare contributi, i collaboratori potrebbero aprire pull request sul repository sorgente. Il deploy avverrebbe solo dopo il merge, mantenendo il controllo su cosa viene pubblicato.</p>
<p><strong>Ambienti multipli</strong>: potresti configurare workflow diversi per branch diversi. Ad esempio, il branch <code>develop</code> potrebbe pubblicare su un sito di staging, mentre <code>main</code> pubblica su produzione.</p>
<hr>
<h2>Considerazioni Pratiche</h2>
<p>Se state pensando di implementare un sistema simile, ecco alcuni consigli pratici:</p>
<p><strong>Testare localmente prima di pushare</strong>. Assicuratevi che il build funzioni sul vostro computer prima di affidarvi all&#39;automazione. Debugging di workflow falliti è meno divertente di quanto sembri.</p>
<p><strong>Usare <code>npm ci</code> invece di <code>npm install</code></strong>. Il primo è più veloce e garantisce build riproducibili, usando esattamente le versioni specificate nel lockfile.</p>
<p><strong>Abilitare il caching delle dipendenze</strong>. GitHub Actions può memorizzare le dipendenze npm tra un&#39;esecuzione e l&#39;altra, velocizzando significativamente i build successivi.</p>
<p><strong>Monitorare i workflow</strong>. Ogni tanto date un&#39;occhiata alla tab Actions. Se qualcosa fallisce, lo saprete solo guardando lì (a meno che non configuriate notifiche, che è un&#39;altra buona idea).</p>
<hr>
<h2>Conclusioni</h2>
<p>L&#39;automazione del deploy è uno di quegli investimenti che ripagano ogni singolo giorno. Il tempo speso a configurare il workflow viene recuperato rapidamente, e soprattutto elimina quella frizione psicologica che a volte ci impedisce di pubblicare.</p>
<p>Quando sai che pubblicare significa semplicemente &quot;commit e push&quot;, pubblichi di più. Quando non devi preoccuparti del deploy, puoi concentrarti su quello che conta davvero: i contenuti.</p>
<p>GitHub Actions e GitHub Pages formano un&#39;accoppiata potente per chiunque gestisca un sito statico. Sono gratuiti, affidabili, e una volta configurati spariscono sullo sfondo, facendo il loro lavoro in silenzio.</p>
<p>La separazione tra repository sorgente e repository di pubblicazione aggiunge un livello di pulizia architetturale che apprezzo particolarmente. Non è necessaria per tutti, ma se vi trovate a gestire progetti dove la distinzione tra &quot;sviluppo&quot; e &quot;produzione&quot; è importante, è un pattern da considerare.</p>
<p>E la prossima volta che fate push e il vostro sito si aggiorna da solo, prendetevi un momento per apprezzare la magia. Anche se sapete esattamente come funziona, resta comunque un po&#39; magica.</p>
      </article>
    
  </main>
  
  <footer>
    <div class="container">
      <p>&copy; 2024 Danilo Paissan. Tutti i diritti riservati.</p>
    </div>
  </footer>
  
  
      <div id="cookie-banner" class="cookie-banner" style="display: none;">
        <div class="cookie-content">
          <h3>Informativa sui Cookie</h3>
          <p>Questo sito non utilizza cookie di tracciamento o di profilazione. I cookie tecnici vengono utilizzati solo per il funzionamento del sito.</p>
          <div class="cookie-buttons">
            <button onclick="acceptCookies()" class="btn-accept">Accetto</button>
            <button onclick="rejectCookies()" class="btn-reject">Rifiuto</button>
          </div>
        </div>
      </div>
      
      <style>
        .cookie-banner {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          background: var(--color-dark-gray);
          color: white;
          z-index: 1000;
          padding: 1rem;
        }
        
        .cookie-content {
          max-width: 800px;
          margin: 0 auto;
        }
        
        .cookie-content h3 {
          margin-bottom: 0.5rem;
        }
        
        .cookie-content p {
          margin-bottom: 1rem;
        }
        
        .cookie-buttons {
          display: flex;
          gap: 1rem;
        }
        
        .cookie-buttons button {
          padding: 0.5rem 1rem;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
        }
        
        .btn-accept {
          background: var(--color-light-silver);
          color: var(--color-dark-gray);
        }
        
        .btn-reject {
          background: var(--color-medium-gray);
          color: white;
        }
        
        .cookie-rejected {
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          height: 100vh;
          text-align: center;
        }
      </style>
      
      <script>
        function checkCookieConsent() {
          const consent = localStorage.getItem('cookieConsent');
          if (consent === 'rejected') {
            document.body.innerHTML = `
              <div class="cookie-rejected">
                <h2>È necessario accettare i cookie per accedere al sito.</h2>
                <button onclick="resetCookieConsent()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: var(--color-medium-gray); color: white; border: none; border-radius: 4px; cursor: pointer;">
                  Accetto
                </button>
              </div>
            `;
            return;
          }
          if (!consent) {
            document.getElementById('cookie-banner').style.display = 'block';
          }
        }
        
        function acceptCookies() {
          localStorage.setItem('cookieConsent', 'accepted');
          document.getElementById('cookie-banner').style.display = 'none';
        }
        
        function rejectCookies() {
          localStorage.setItem('cookieConsent', 'rejected');
          location.reload();
        }
        
        function resetCookieConsent() {
          localStorage.removeItem('cookieConsent');
          location.reload();
        }
        
        // Check consent on page load
        document.addEventListener('DOMContentLoaded', checkCookieConsent);
      </script>
    
  
  <script>
    function switchLanguage(lang) {
      const currentPath = window.location.pathname;
      const filename = currentPath.split('/').pop() || 'index.html';
      
      let newFilename;
      if (lang === 'en') {
        if (filename === 'index.html') {
          newFilename = 'index-en.html';
        } else if (filename === 'chi-sono.html') {
          newFilename = 'about.html';
        } else if (!filename.includes('-en.html')) {
          newFilename = filename.replace('.html', '-en.html');
        } else {
          newFilename = filename;
        }
      } else {
        if (filename === 'index-en.html') {
          newFilename = 'index.html';
        } else if (filename === 'about.html') {
          newFilename = 'chi-sono.html';
        } else if (filename.includes('-en.html')) {
          newFilename = filename.replace('-en.html', '.html');
        } else {
          newFilename = filename;
        }
      }
      
      window.location.href = newFilename;
    }
  </script>
</body>
</html>